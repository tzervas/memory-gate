import asyncio
import os
import argparse
from datetime import datetime
from typing import List, Optional

from memory_gate.memory_protocols import LearningContext, MemoryAdapter, KnowledgeStore
from memory_gate.storage.in_memory import InMemoryKnowledgeStore # Using InMemory for CLI
from memory_gate.memory_gateway import MemoryGateway
# Import other components if the full system needs to run, or keep minimal for CLI
# from memory_gate.consolidation import ConsolidationWorker
# from memory_gate.agent_interface import SimpleEchoAgent
# from memory_gate.agents import InfrastructureAgent
# from memory_gate.metrics import start_metrics_server


# Global list to keep track of background tasks for graceful shutdown (if any)
background_tasks: List[asyncio.Task[None]] = []


class PassthroughAdapter(MemoryAdapter[LearningContext]):
    """A simple adapter that passes through the context, optionally adjusting importance."""

    async def adapt_knowledge(
        self, context: LearningContext, feedback: float | None = None
    ) -> LearningContext:
        if feedback is not None and 0.0 <= feedback <= 1.0:
            context.importance = (context.importance + feedback) / 2.0
        elif feedback is not None:
            context.importance = feedback
        return context


# --- CLI Specific Functions ---

async def cli_store_experience(gateway: MemoryGateway[LearningContext], args: argparse.Namespace) -> None:
    """Handles the 'store' CLI command."""
    metadata = {}
    if args.metadata:
        for item in args.metadata:
            key, value = item.split('=', 1)
            metadata[key] = value

    context = LearningContext(
        content=args.content,
        domain=args.domain,
        timestamp=datetime.now(),
        importance=args.importance,
        metadata=metadata
    )
    adapted_context = await gateway.learn_from_interaction(context, args.feedback)
    # learn_from_interaction already calls store.store_experience internally via a task
    # To ensure it completes for CLI, we might need to wait for the task or make it synchronous for CLI.
    # For simplicity, we'll assume the asyncio.create_task in MemoryGateway is quick enough
    # or for a CLI, one might want direct await.
    # Let's retrieve the key generated by _generate_key to confirm storage.
    key = gateway._generate_key(adapted_context)
    print(f"Stored experience with key: {key}. Content: '{adapted_context.content}', Importance: {adapted_context.importance}")
    # Ensure tasks are awaited in CLI context
    await asyncio.sleep(0.01) # Give time for the asyncio.create_task to run


async def cli_retrieve_context(gateway: MemoryGateway[LearningContext], args: argparse.Namespace) -> None:
    """Handles the 'retrieve' CLI command."""
    contexts = await gateway.store.retrieve_context(
        query=args.query,
        limit=args.limit,
        domain_filter=args.domain_filter
    )
    if contexts:
        print(f"Retrieved {len(contexts)} context(s):")
        for i, ctx in enumerate(contexts):
            print(f"  {i+1}. Content: '{ctx.content}'")
            print(f"     Domain: {ctx.domain}, Timestamp: {ctx.timestamp.isoformat()}, Importance: {ctx.importance}")
            if ctx.metadata:
                print(f"     Metadata: {ctx.metadata}")
    else:
        print("No relevant context found.")


async def main_cli_handler(args: argparse.Namespace) -> None:
    """Initializes gateway and handles CLI commands."""
    # For CLI, using InMemoryKnowledgeStore for simplicity
    knowledge_store: KnowledgeStore[LearningContext] = InMemoryKnowledgeStore()
    memory_adapter: MemoryAdapter[LearningContext] = PassthroughAdapter()
    gateway = MemoryGateway(adapter=memory_adapter, store=knowledge_store)

    if args.command == "store":
        await cli_store_experience(gateway, args)
    elif args.command == "retrieve":
        await cli_retrieve_context(gateway, args)
    else:
        print(f"Unknown command: {args.command}")
        # This path should ideally not be reached if argparse is set up correctly.


# --- Full System Startup (can be kept for non-CLI execution) ---
async def main_async_server() -> None:
    """Initializes and starts the MemoryGate components for server mode."""
    # This is the original main_async, renamed and potentially simplified if CLI is primary
    print("Initializing MemoryGate System (Server Mode)...")
    # ... (original server setup code from previous main_async)
    # For now, let's keep it minimal as the focus is CLI
    # Metrics Server Configuration
    METRICS_PORT = int(os.getenv("METRICS_PORT", "8008"))
    METRICS_HOST = os.getenv("METRICS_HOST", "0.0.0.0")

    # Initialize Storage (e.g. VectorMemoryStore for server mode)
    # knowledge_store = VectorMemoryStore(...)
    # memory_adapter = PassthroughAdapter()
    # memory_gateway = MemoryGateway(adapter=memory_adapter, store=knowledge_store)
    # print("MemoryGateway initialized for server mode.")
    # Start metrics server, consolidation worker etc.
    # start_metrics_server(port=METRICS_PORT, addr=METRICS_HOST)
    print("Server mode components would be initialized here.")
    print("For this iteration, server mode is placeholder.")

    print("\nMemoryGate System (Server Mode) would be running. Press Ctrl+C to exit.")
    try:
        while True:
            await asyncio.sleep(3600)
    except asyncio.CancelledError:
        print("Server task cancelled. Shutting down...")


def main() -> None:
    parser = argparse.ArgumentParser(description="MemoryGate CLI and Server Control.")
    subparsers = parser.add_subparsers(dest="mode", help="Run mode: 'cli' or 'server'")
    subparsers.required = True # Make mode selection mandatory

    # --- CLI Mode Parser ---
    cli_parser = subparsers.add_parser("cli", help="Run in CLI mode for direct interaction.")
    cli_subparsers = cli_parser.add_subparsers(dest="command", help="CLI command to execute")
    cli_subparsers.required = True

    # Store command
    store_parser = cli_subparsers.add_parser("store", help="Store a new learning experience.")
    store_parser.add_argument("content", type=str, help="Content of the learning experience.")
    store_parser.add_argument("--domain", type=str, default="general", help="Domain of the experience.")
    store_parser.add_argument("--importance", type=float, default=1.0, help="Importance score (0.0-1.0).")
    store_parser.add_argument("--feedback", type=float, help="Feedback score for adaptation (optional).")
    store_parser.add_argument("--metadata", nargs='*', help="Metadata key-value pairs (e.g., key1=value1 key2=value2).")

    # Retrieve command
    retrieve_parser = cli_subparsers.add_parser("retrieve", help="Retrieve relevant learning context.")
    retrieve_parser.add_argument("query", type=str, help="Query string to search for.")
    retrieve_parser.add_argument("--limit", type=int, default=5, help="Maximum number of contexts to retrieve.")
    retrieve_parser.add_argument("--domain-filter", type=str, help="Filter by domain (optional).")

    # --- Server Mode Parser ---
    server_parser = subparsers.add_parser("server", help="Run in Server mode (e.g., with metrics, consolidation).")
    # Add server-specific arguments if any, e.g., --port, --config-file

    args = parser.parse_args()

    loop = asyncio.get_event_loop()
    main_task: Optional[asyncio.Task[None]] = None

    try:
        if args.mode == "cli":
            main_task = loop.create_task(main_cli_handler(args))
            loop.run_until_complete(main_task)
        elif args.mode == "server":
            # For now, server mode is a placeholder
            print("Server mode selected. This is currently a placeholder.")
            # To run the full server:
            # main_task = loop.create_task(main_async_server())
            # loop.run_until_complete(main_task)
        else:
            # Should not happen if subparsers.required = True
            parser.print_help()

    except KeyboardInterrupt:
        print("KeyboardInterrupt received. Shutting down...")
    finally:
        if main_task and not main_task.done():
            main_task.cancel()
            # Ensure the task has time to process cancellation
            # loop.run_until_complete(main_task) # This can lead to "Cannot cancel a completed task"
            # A simple way to allow cleanup:
            if not loop.is_closed():
                # Gather remaining tasks, including the cancelled main_task
                # This might be overly complex for simple CLI; for server it's more relevant
                pending = asyncio.all_tasks(loop=loop)
                if pending: # Check if there are any tasks
                    # Create a future to wait for these tasks, then run loop until it's done
                    # This is a bit of a hack to ensure cleanup in some scenarios
                    # More robust shutdown patterns exist (e.g. using signals, dedicated shutdown functions)
                    # loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                    pass # For CLI, simple cancellation is often enough.

        print("MemoryGate application finished.")


if __name__ == "__main__":
    main()
